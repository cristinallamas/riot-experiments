{
  "_args": [
    [
      {
        "raw": "nash@^2.0.0",
        "scope": null,
        "escapedName": "nash",
        "name": "nash",
        "rawSpec": "^2.0.0",
        "spec": ">=2.0.0 <3.0.0",
        "type": "range"
      },
      "/Users/cristinallamas/FE/playground/riot-experiments/todo-control/node_modules/superstatic"
    ]
  ],
  "_from": "nash@>=2.0.0 <3.0.0",
  "_id": "nash@2.0.4",
  "_inCache": true,
  "_location": "/nash",
  "_nodeVersion": "5.1.1",
  "_npmUser": {
    "name": "scottcorgan",
    "email": "scottcorgan@gmail.com"
  },
  "_npmVersion": "2.14.14",
  "_phantomChildren": {},
  "_requested": {
    "raw": "nash@^2.0.0",
    "scope": null,
    "escapedName": "nash",
    "name": "nash",
    "rawSpec": "^2.0.0",
    "spec": ">=2.0.0 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/superstatic"
  ],
  "_resolved": "https://registry.npmjs.org/nash/-/nash-2.0.4.tgz",
  "_shasum": "cb964791cefd376d59cfacd80109274616aa15d2",
  "_shrinkwrap": null,
  "_spec": "nash@^2.0.0",
  "_where": "/Users/cristinallamas/FE/playground/riot-experiments/todo-control/node_modules/superstatic",
  "author": {
    "name": "Scott Corgan"
  },
  "bugs": {
    "url": "https://github.com/scottcorgan/nash/issues"
  },
  "dependencies": {
    "async": "^1.3.0",
    "flat-arguments": "^1.0.0",
    "lodash": "^3.10.0",
    "minimist": "^1.1.0"
  },
  "description": "Craft command-line Masterpieces",
  "devDependencies": {
    "@tap-format/spec": "0.2.0",
    "eslint": "^0.24.0",
    "tape": "^4.0.0"
  },
  "directories": {},
  "dist": {
    "shasum": "cb964791cefd376d59cfacd80109274616aa15d2",
    "tarball": "https://registry.npmjs.org/nash/-/nash-2.0.4.tgz"
  },
  "gitHead": "95ec65323f22e271dbc9e471e41543e587d5831d",
  "homepage": "https://github.com/scottcorgan/nash",
  "keywords": [
    "command",
    "line",
    "cli",
    "bash",
    "terminal",
    "commander",
    "prompt"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "scottcorgan",
      "email": "scottcorgan@gmail.com"
    }
  ],
  "name": "nash",
  "optionalDependencies": {},
  "readme": "# nash [![NPM Module](http://img.shields.io/npm/v/nash.svg?style=flat-square)](https://npmjs.org/package/nash) [![Downloads a Month](https://img.shields.io/npm/dm/nash.svg?style=flat-square)](https://npmjs.org/package/nash) [ ![Travis Status for scottcorgan/nash](https://img.shields.io/travis/scottcorgan/nash.svg?style=flat-square)](https://travis-ci.org/scottcorgan/nash)\n\nCraft command-line masterpieces\n\n**API**\n\n* [Cli](#cli)\n  * [run](#runargv)\n  * [command](#commandname-names-)\n  * [default](#defaultcallback)\n  * [flag](#flagname-names-)\n  * [beforeAll](#beforeallcallback-callback-)\n  * [afterAll](#afterallcallback-callback-)\n  * [set](#setname-value)\n  * [get](#getname)\n  * [register](#registerplugin-options)\n* [Command](#command)\n  * [handler](#handlercallback)\n  * [task](#taskname-name-)\n  * [flag](#flagname-name-)\n  * [before](#beforecallback-callback-)\n  * [after](#aftercallback-callback-)\n  * [name](#namename-name-)\n* [Flag](#flag)\n  * [handler](#handlercallback-1)\n  * [override](#override)\n  * [name](#namename-name--1)\n* [Plugins](#plugins)\n\n## Install\n\n```\nnpm install nash --save\n```\n\n## Usage\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.beforeAll(function () {\n  \n  // Run this before all commands\n});\n\ncli.flag('-p')\n  .handler(function (value, done) {\n    \n    // Do something when this flag is triggered\n    done();\n  });\n\ncli.command('list')\n  .handler(function (data, flags, done) {\n    \n    // Do something here\n    done();\n  });\n\ncli.run(process.argv, function (err) {\n\n  // All done!\n});\n```\n\n## Cli\n\n### run(argv[, callback])\n\nRun the cli app with the given arguments. Normally you'd pass in `process.argv`. The callback can be used to execute more code after everything has completed.\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.command('some-command')\n  .handler(function (data, flags, done) {\n  \n    console.log('Some Command');\n    done();\n  });\n  \ncli.run(process.argv, function () {\n  \n  // All done\n});\n```\n\n### command(name[, names, ...])\n\nCreate a command with the given name(s). Supports a single name, and array of names, or multiple names separated by commas as arguments to the command method. Returns an instance of [`Command`](#command).\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.command('some-command')\n  .handler(function (data, flags, done) {\n  \t\n    // Do something here\n    done();\n  });\n```\n\n### default(callback)\n\nDeclare a default command to run if no command is provided. This is useful for small cli apps that have no commands and do only one task. This inherits the same api as a normal command.\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.default()\n  .handler(function (data, flags, done) {\n  \n    // Do stuff here\n    done();\n  });\n\ncli.run([]);\n```\n\n### flag(name[, names, ...])\n\nCreate a flag with the given name(s). Supports a single name, and array of names, or multiple names separated by commas as arguments to the command method. Returns an instance of [`Flag`](#flag).\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.flag('-f')\n  .handler(function (value, done) {\n  \n  \t// Do something with this flag value\n    done();\n  });\n```\n\n### beforeAll(callback[, callback, ...])\n\nAdd a function or functions to be called before any commands or flags are run. The callback is passed to arguments\":\n\n* `data` - the values passed in from the the terminal. \n* `flags` - a key/value map of flags and their corresponding values\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.beforeAll(function (data, flags, done) {\n\n  // data === ['value']\n  // flags === {f: 'flag-value'}\n  done();\n});\n\ncli.command('some-command')\n  .handler(function (data, flags, doen) {\n  \n    done();\n  })\n  .flag('-f')\n    .handler(function (val, done) {\n    \n      done();\n    });\n\n// This is usually sent in via process.argv\ncli.run(['', '', 'some-command', 'value', '-f', 'flag-value']); \n```\n\n### afterAll(callback[, callback, ...])\n\nDoes the same thing as `beforeAll()`, except runs the callbacks after all the commands and flags are run.\n\n### set(name, value)\n\nCli-level/app-level settings. Set the given `name` to the given `value\n\n* `name` - name of key. Name, can also be a key/value object of multiple values\n* `value` - value of name\n\n```js\n\nvar nash = require('nash');\nvar cli = nash();\n\ncli.set('key', 'value');\ncli.set({\n  key1: 'value1',\n  key2: 'value2'\n});\n\n```\n\n### get(name)\n\nCli-level/app-level getter for settings.\n\n* `name` - name of key to get\n\n### register(plugin(s), callback)\n\nRegister a plugin with your command-line application. This provides extensibility and modularity. See [Plugins](#plugins) for more information.\n\n## Command\n\nRunning `cli.command('name')` creates an instance of the Command class with following methods available:\n\n### handler(callback)\n\nThe callback gets executed when the command is called. Any values passed in to the run method on the cli get passed into the callback. You must call the `done()` callback to pass execution back to the cli.\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\n\n// Sync mode\ncli.command('some-command')\n  .handler(function (data, flags, done) {\n\n    // value === 'value'\n    done();\n  });\n\n// Usually passed process.argv\ncli.run(['', '', 'some-command', 'value']);\n\n```\n\n### task(name[, name, ...])\n\nCreates a sub task of the command. This is similar to the command tasks that the Heroku toolbelt has. This creates a command that looks like `command:task` when running. Calling `task()` returns and instance of [`Command`](#command).\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.command('command')\n  .task('task', 'tsk')\n  .handler(function (data, flags, done) {\n  \t\n    // Do something here\n    done();\n  });\n  \ncli.run(['', '', 'command:task']);\n```\n\n### flag(name[, name, ...])\n\nCreates a command-specific flag that only runs for that command. Returns an instance of [`Flag`](#flag).\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.command('command')\n  .flag('-f', '--flag')\n  .handler(function (value, done) {\n  \n    // Do something here\n    done();\n  });\n\ncli.run(['', '', 'command', '-f']);\n```\n\n### before(callback[, callback, ...])\n\nAdd a function or functions to be called before the command and the command's flags are run. This has the same callback signature as Cli's [`beforeAll()`](#beforeallcallback-callback-)\n\n### after(callback[, callback, ...])\n\nThis is the same as the `before()` method, except this is called after the command and all it's flags run.\n\n### name(name[, name, ...])\n\nAdd more names to the command. Helpful if you want aliases or mispellings to trigger the command. This can also be used to get all the aliases for a given command.\n\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.command('command')\n  .name('cmd', 'commnd')\n```\n\n## Flag\n\nRunning `cli.flag('name')` or `cli.command('name').flag('name')` creates an instance of the Flag class. If created under a command, the flag only runs with that command. The Flag class has the following methods available:\n\n### handler(callback)\n\nThe callback gets executed when the flag is called. Any values passed in to the run method on the cli get passed into the callback. The `done()` callback must be called to pass execution back to the cli.\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\n\n// Sync mode\ncli.command('some-command')\n  .flag('-f')\n  .handler(function (value, done) {\n  \n    // Do something here\n    done();\n  });\n\n\n// Usually passed process.argv\ncli.run(['', '', 'some-command', '-f']);\n\n```\n\n### override()\n\nIf no value or a value of `true` is passed in, this command specific flag will override the cli/global flag. If set to `false` or not called, the flag will run in series after the cli/global flag.\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\n\ncli.flag('-f')\n\t.handler(function (value, done) {\n    \n    done():\n  });\n\ncli.command('some-command')\n  .flag('-f')\n  .override()\n  .handler(function (value, done) {\n  \n    // Only this flag runs for -f\n    done();\n  });\n  \ncli.run(['', '', 'some-command', '-f']);\n```\n\n### name(name[, name, ...])\n\nAdd more names to the flag. Helpful if you want aliases or mispellings to trigger the flag.\n\n\n```js\nvar nash = require('nash');\nvar cli = nash();\n\ncli.command('command')\n\t.flag('-f')\n\t  .name('--flag', '--flaggling');\n```\n\n## Plugins\n\nNash lets you register plugins via the [`register`](#registerplugin-options) method on the cli object. This makes it easier to break up your app as it grows.\n\nYOu can register an array of plugins or a single plugin. Each object used to register the plugin must contain a `register` key with the value being the plugin function. See below for examples.\n\nOptionally, you can provide an options object to pass to each plugin.\n\n**Example of registering a plugin:**\n\n```js\nvar nash = require('nash');\nvar myPlugin = require('my-plugin');\nvar cli = nash();\n\ncli.register([{\n  register: myPlugin,\n  options: {\n    key: 'value'\n  }\n}], function (err) {\n\n  // Done loading plugins\n});\n```\n\n**Example plugin:**\n\n```js\nmodule.exports = function (cli, options, done) {\n  \n  cli.command('something')\n    .handler(function (data, flags, done) {\n      \n      // Do something here\n      done();\n    });\n  \n  done();\n};\n```\n\nEach plugin must export a function. This method is called and given the arguments:\n\n1. Cli object.\n2. Options you pass when registering the plugin.\n3. Callback. This must be called in order to complete the registration process\n\n\n## Run Tests\n\n```\nnpm install\nnpm test\n```\n\n## License\n\n[MIT](https://github.com/scottcorgan/nash/blob/master/LICENSE)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/scottcorgan/nash.git"
  },
  "scripts": {
    "jshint": "jshint ./lib/** ./test/**",
    "lint": "eslint lib/",
    "test": "npm run lint && tape test/** | tap-format-spec"
  },
  "version": "2.0.4"
}
